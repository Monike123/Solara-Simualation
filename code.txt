"""
scene.py

Rendering setup

Manages the 3D scene rendering including bodies, trails, potential surfaces,
and coordinate systems. This is the main rendering coordinator.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation
from scipy.ndimage import gaussian_filter
import matplotlib.patches as patches

from .surface import PotentialSurface
from .camera import Camera, CameraMode
from .ui import UIManager
from constants import VISUAL_RADIUS_SCALE, TRAIL_DECIMATE

__all__ = ["Scene", "MatplotlibRenderer"]

RADIUS_SCALE_PLANETS = 20   # makes planets visible
RADIUS_SCALE_SUN = 15        # keeps Sun large but not absurd

def get_display_radius(body):
    """Return scaled radius for visualization only."""
    if body.name.lower() == "sun":
        return body.radius * RADIUS_SCALE_SUN
    else:
        return body.radius * RADIUS_SCALE_PLANETS
    


class Scene:
    """
    Main scene manager for the solar system visualization.
    
    Coordinates all rendering components including bodies, trails,
    potential surfaces, and user interface elements.
    """
    
    def __init__(self, system, renderer_type="matplotlib"):
        """
        Initialize the scene.
        
        Parameters
        ----------
        system : SolarSystem
            Solar system to render
        renderer_type : str
            Type of renderer to use ("matplotlib", "opengl", etc.)
        """
        self.system = system
        self.camera = Camera()
        self.ui = UIManager()
        
        # Rendering components
        self.potential_surface = PotentialSurface()
        
        # Rendering settings
        self.show_trails = True
        self.show_surface = True
        self.show_axes = True
        self.show_labels = True
        
        # Create renderer
        if renderer_type == "matplotlib":
            self.renderer = MatplotlibRenderer(self)
        else:
            raise ValueError(f"Unknown renderer type: {renderer_type}")
        
        # Animation state
        self.paused = False
        self.time_scale = 1.0
        self.frame_count = 0
    
    def update(self, dt):
        """
        Update the scene for one frame.
        
        Parameters
        ----------
        dt : float
            Time step in years
        """
        # Update camera
        self.camera.update(dt)
        
        # Update UI
        self.ui.update(dt)
        
        # Update potential surface periodically
        if self.frame_count % 10 == 0:  # Update every 10 frames
            self.potential_surface.update(self.system.bodies)
        
        # Add trail points
        if self.frame_count % TRAIL_DECIMATE == 0:
            self.system.add_trail_points()
        
        self.frame_count += 1
    
    def render(self):
        """Render the current frame."""
        self.renderer.render()
    
    def handle_mouse_click(self, x, y):
        """Handle mouse click events."""
        return self.ui.handle_mouse_click(x, y, self.system.bodies, self.camera)
    
    def handle_key_press(self, key):
        """Handle keyboard input."""
        result = self.ui.handle_key_press(key, self.system, self.camera)
        
        if result == 'toggle_pause':
            self.paused = not self.paused
            return self.paused
        
        return None
    
    def toggle_trails(self):
        """Toggle trail visibility."""
        self.show_trails = not self.show_trails
        return self.show_trails
    
    def toggle_surface(self):
        """Toggle surface visibility."""
        self.show_surface = not self.show_surface
        return self.show_surface
    
    def set_camera_mode(self, mode):
        """Set camera mode."""
        self.camera.set_mode(mode)

class MatplotlibRenderer:
    """
    Matplotlib-based renderer for the solar system visualization.
    
    Provides a simple but functional 3D visualization using matplotlib.
    """
    
    def __init__(self, scene):
        """
        Initialize the matplotlib renderer.
        
        Parameters
        ----------
        scene : Scene
            Scene to render
        """
        self.scene = scene
        
        # Create figure and 3D axis
        self.fig = plt.figure(figsize=(12, 8))
        self.ax = self.fig.add_subplot(111, projection='3d')
        self.ax.set_facecolor("black")
        self.fig.patch.set_facecolor("black")
        self.ax.set_xlabel("X (AU)", color="white")
        self.ax.set_ylabel("Y (AU)", color="white")
        self.ax.set_zlabel("Z (AU)", color="white")
        self.ax.set_xlabel("X [AU]", color="white")
        self.ax.set_ylabel("Y [AU]", color="white")
        self.ax.set_zlabel("Potential", color="white")
        self.ax.tick_params(colors="white")
        
        # Set up the plot
        self._setup_plot()
        
        # Store plot elements for updating
        self.body_plots = {}
        self.trail_plots = {}
        self.surface_plot = None
        
        # Text elements
        self.info_text = None
        self.control_text = None

        #max_range = 5  # adjust as needed
        #self.ax.set_xlim(-max_range, max_range)
        #self.ax.set_ylim(-max_range, max_range)
        #self.ax.set_zlim(-max_range, max_range)

        self.ax.view_init(elev=20, azim=30)
        self.ax.dist = 8
    
    def _setup_plot(self):
        """Set up the 3D plot appearance."""
        self.ax.set_xlabel('X [AU]', color="white")
        self.ax.set_ylabel('Y [AU]', color="white")
        self.ax.set_zlabel('Z [AU]', color="white")

        self.ax.tick_params(colors="white")
        
        # Set equal aspect ratio
        self.ax.set_box_aspect([1,1,1])
        
        # Set initial view limits
        self._update_view_limits()

        for axis in [self.ax.xaxis, self.ax.yaxis, self.ax.zaxis]:
            axis.label.set_color("white")
            axis.set_tick_params(colors="white")
        
        # Style
        self.ax.set_facecolor("black")
        self.fig.patch.set_facecolor("black")
        self.ax.grid(True, alpha=0.3)
        self.ax.xaxis.pane.fill = False
        self.ax.yaxis.pane.fill = False
        self.ax.zaxis.pane.fill = False

    
    def _update_view_limits(self):
        """Update view limits based on camera and bodies."""
        if self.scene.camera.mode == CameraMode.FOCUS and self.scene.camera.focus_body:
            # Focus mode: tight view around selected body
            center = self.scene.camera.focus_body.pos
            radius = self.scene.camera.distance * 0.5
            
            self.ax.set_xlim(center[0] - radius, center[0] + radius)
            self.ax.set_ylim(center[1] - radius, center[1] + radius)
            self.ax.set_zlim(center[2] - radius, center[2] + radius)
        else:
            # Overview mode: show entire system
            max_dist = 0
            for body in self.scene.system.bodies:
                dist = np.linalg.norm(body.pos)
                max_dist = max(max_dist, dist)
            
            limit = max(max_dist * 1.2, 10.0)
            self.ax.set_xlim(-limit, limit)
            self.ax.set_ylim(-limit, limit)
            self.ax.set_zlim(-limit, limit)
    
    def render(self):
        """Render the current frame."""
        # Clear previous frame
        self.ax.clear()
        self._setup_plot()
        
        # Update view limits
        self._update_view_limits()
        
        # Render potential surface
        if self.scene.show_surface:
            self._render_surface()
        
        # Render bodies
        self._render_bodies()
        
        # Render trails
        if self.scene.show_trails:
            self._render_trails()
        
        # Render coordinate axes
        if self.scene.show_axes:
            self._render_axes()
        
        # Render UI elements
        self.scene.ui.render(self)
        
        # Update display
        plt.draw()
    
    def _render_bodies(self):
        """Render all celestial bodies."""
        for body in self.scene.system.bodies:
            # Calculate visual radius
            visual_radius = get_display_radius(body)
            self.ax.scatter(
            body.pos[0], body.pos[1], body.pos[2],
            s=max(20, visual_radius * 10000),  # scatter size is in points^2
            c=[body.color],
            alpha=0.9,
            edgecolors='white' if body == self.scene.ui.selected_body else 'none',
            linewidth=2
            )

            # Add label above the scaled "surface"
            if self.scene.show_labels:
                self.ax.text(
                    body.pos[0], body.pos[1], body.pos[2] + visual_radius,
                    body.name,
                    fontsize=8,
                    color='white',
                    ha='center'
                )

    
    def _render_trails(self):
        """Render orbital trails."""
        for body in self.scene.system.bodies:
            if len(body.trail) > 1:
                trail = np.array(body.trail)
                trail = trail[-300:]
                self.ax.plot(
                    trail[:, 0], trail[:, 1], trail[:, 2],
                    color=body.color,
                    alpha=0.6,
                    linewidth=1
                )
    
    def _render_surface(self):
        """Render smooth Gaussian-like gravitational potential surface with labels."""
        # Create a smooth grid for each body
        for body in self.scene.system.bodies:
            if body.name.lower() == "sun" or body.mass > 1e-5:  # Only show for massive bodies
            
                # Create a local grid around the body
                extent = max(2.0, body.mass * 50)  # Adjust size based on mass
                grid_size = 30
            
                # Grid centered on the body
                x_center, y_center, z_center = body.pos
                x_range = np.linspace(x_center - extent, x_center + extent, grid_size)
                z_range = np.linspace(z_center - extent, z_center + extent, grid_size)
                X, Z = np.meshgrid(x_range, z_range)
            
                # Create smooth Gaussian-like gravitational well
                sigma = extent / 4  # Controls the width of the well
            
                # Calculate distance from body center for each grid point
                dx = X - x_center
                dz = Z - z_center
                r_squared = dx**2 + dz**2
            
                # Gaussian-like potential well (inverted Gaussian)
                max_depth = -body.mass * 10  # Depth proportional to mass
                Y = max_depth * np.exp(-r_squared / (2 * sigma**2))
            
                # Smooth the surface further
                Y = gaussian_filter(Y, sigma=1.0)
            
                # Render smooth surface
                self.ax.plot_wireframe(
                    X, Z, Y + y_center,  # Offset by body's y-position
                    alpha=0.4,
                    color='cyan',
                    linewidth=0.4,
                    rstride=2,
                    cstride=2)
            
                # Add gravity well value label at the bottom
                min_potential = np.min(Y)
                label_text = f"{body.name}\nGravity: {abs(min_potential):.2e}"
            
                self.ax.text(
                    x_center, y_center + min_potential - 0.5 ,z_center ,
                    label_text,
                    fontsize=8,
                    color='white',
                    ha='center',
                    va='top',
                    bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7))
    
    def _render_axes(self):
        """Render coordinate system axes."""
        # Origin marker
        self.ax.scatter([0], [0], [0], c='white', s=50, marker='+')
        
        # Axis lines (small)
        axis_length = 2.0
        self.ax.plot([0, axis_length], [0, 0], [0, 0], 'r-', alpha=0.5, linewidth=2)  # X
        self.ax.plot([0, 0], [0, axis_length], [0, 0], 'g-', alpha=0.5, linewidth=2)  # Y
        self.ax.plot([0, 0], [0, 0], [0, axis_length], 'b-', alpha=0.5, linewidth=2)  # Z
    

    
    def render_text_panel(self, position, lines):
        """Render a text panel (for UI components)."""
        text = '\n'.join(lines)
        x, y = position
        
        # Convert to normalized coordinates
        x_norm = x / self.fig.get_size_inches()[0] / self.fig.dpi
        y_norm = 1.0 - (y / self.fig.get_size_inches()[1] / self.fig.dpi)
        
        self.ax.text2D(x_norm, y_norm, text, transform=self.ax.transAxes,
                      fontsize=8, color='white', verticalalignment='top',
                      bbox=dict(boxstyle='round', facecolor='black', alpha=0.7))
    
    def show(self):
        """Show the plot window."""
        plt.show()
    
    def save_frame(self, filename):
        """Save current frame to file."""
        self.fig.savefig(filename, facecolor='black', dpi=150)


#################################################################################################################################

scene.py 2

"""
scene.py

Rendering setup

Manages the 3D scene rendering including bodies, trails, potential surfaces,
and coordinate systems. This is the main rendering coordinator.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation
from scipy.ndimage import gaussian_filter
import matplotlib.patches as patches

from .surface import PotentialSurface
from .camera import Camera, CameraMode
from .ui import UIManager
from constants import VISUAL_RADIUS_SCALE, TRAIL_DECIMATE

__all__ = ["Scene", "MatplotlibRenderer"]

RADIUS_SCALE_PLANETS = 20   # makes planets visible
RADIUS_SCALE_SUN = 15        # keeps Sun large but not absurd

def get_display_radius(body):
    """Return scaled radius for visualization only."""
    if body.name.lower() == "sun":
        return body.radius * RADIUS_SCALE_SUN
    else:
        return body.radius * RADIUS_SCALE_PLANETS
    


class Scene:
    """
    Main scene manager for the solar system visualization.
    
    Coordinates all rendering components including bodies, trails,
    potential surfaces, and user interface elements.
    """
    
    def __init__(self, system, renderer_type="matplotlib"):
        """
        Initialize the scene.
        
        Parameters
        ----------
        system : SolarSystem
            Solar system to render
        renderer_type : str
            Type of renderer to use ("matplotlib", "opengl", etc.)
        """
        self.system = system
        self.camera = Camera()
        self.ui = UIManager()
        
        # Rendering components
        self.potential_surface = PotentialSurface()
        
        # Rendering settings
        self.show_trails = True
        self.show_surface = True
        self.show_axes = True
        self.show_labels = True
        
        # Create renderer
        if renderer_type == "matplotlib":
            self.renderer = MatplotlibRenderer(self)
        else:
            raise ValueError(f"Unknown renderer type: {renderer_type}")
        
        # Animation state
        self.paused = False
        self.time_scale = 1.0
        self.frame_count = 0
    
    def update(self, dt):
        """
        Update the scene for one frame.
        
        Parameters
        ----------
        dt : float
            Time step in years
        """
        # Update camera
        self.camera.update(dt)
        
        # Update UI
        self.ui.update(dt)
        
        # Update potential surface periodically
        if self.frame_count % 10 == 0:  # Update every 10 frames
            self.potential_surface.update(self.system.bodies)
        
        # Add trail points
        if self.frame_count % TRAIL_DECIMATE == 0:
            self.system.add_trail_points()
        
        self.frame_count += 1
    
    def render(self):
        """Render the current frame."""
        self.renderer.render()
    
    def handle_mouse_click(self, x, y):
        """Handle mouse click events."""
        return self.ui.handle_mouse_click(x, y, self.system.bodies, self.camera)
    
    def handle_key_press(self, key):
        """Handle keyboard input."""
        result = self.ui.handle_key_press(key, self.system, self.camera)
        
        if result == 'toggle_pause':
            self.paused = not self.paused
            return self.paused
        
        return None
    
    def toggle_trails(self):
        """Toggle trail visibility."""
        self.show_trails = not self.show_trails
        return self.show_trails
    
    def toggle_surface(self):
        """Toggle surface visibility."""
        self.show_surface = not self.show_surface
        return self.show_surface
    
    def set_camera_mode(self, mode):
        """Set camera mode."""
        self.camera.set_mode(mode)

class MatplotlibRenderer:
    """
    Matplotlib-based renderer for the solar system visualization.
    
    Provides a simple but functional 3D visualization using matplotlib.
    """
    
    def __init__(self, scene):
        """
        Initialize the matplotlib renderer.
        
        Parameters
        ----------
        scene : Scene
            Scene to render
        """
        self.scene = scene
        
        # Create figure and 3D axis
        self.fig = plt.figure(figsize=(12, 8))
        self.ax = self.fig.add_subplot(111, projection='3d')
        self.ax.set_facecolor("black")
        self.fig.patch.set_facecolor("black")
        self.ax.set_xlabel("X (AU)", color="white")
        self.ax.set_ylabel("Y (AU)", color="white")
        self.ax.set_zlabel("Z (AU)", color="white")
        self.ax.set_xlabel("X [AU]", color="white")
        self.ax.set_ylabel("Y [AU]", color="white")
        self.ax.set_zlabel("Potential", color="white")
        self.ax.tick_params(colors="white")
        
        # Set up the plot
        self._setup_plot()
        self.body_plots = {}
        self.trail_plots = {}
        self.surface_plot = None
        # Body scatter (one collection for all planets)
        self.body_scatter = self.ax.scatter([], [], [], s=[], c=[], alpha=0.9, edgecolors='none')
        # Body labels (one per body)
        self.body_labels = {
            body.name: self.ax.text(0, 0, 0, "", fontsize=8, color="white", ha="center")
            for body in self.scene.system.bodies
        }
        # Trails (one line per body)
        self.trail_lines = {
            body.name: self.ax.plot([], [], [], color=body.color, alpha=0.6, linewidth=1)[0]
            for body in self.scene.system.bodies
        }
        # Surfaces cached
        self.surface_plots = {}
        
        # Store plot elements for updating
        self.body_plots = {}
        self.trail_plots = {}
        self.surface_plot = None
        
        # Text elements
        self.info_text = None
        self.control_text = None

        #max_range = 5  # adjust as needed
        #self.ax.set_xlim(-max_range, max_range)
        #self.ax.set_ylim(-max_range, max_range)
        #self.ax.set_zlim(-max_range, max_range)

        self.ax.view_init(elev=20, azim=30)
        self.ax.dist = 8
    
    def _setup_plot(self):
        """Set up the 3D plot appearance."""
        self.ax.set_xlabel('X [AU]', color="white")
        self.ax.set_ylabel('Y [AU]', color="white")
        self.ax.set_zlabel('Z [AU]', color="white")

        self.ax.tick_params(colors="white")
        
        # Set equal aspect ratio
        self.ax.set_box_aspect([1,1,1])
        
        # Set initial view limits
        self._update_view_limits()

        for axis in [self.ax.xaxis, self.ax.yaxis, self.ax.zaxis]:
            axis.label.set_color("white")
            axis.set_tick_params(colors="white")
        
        # Style
        self.ax.set_facecolor("black")
        self.fig.patch.set_facecolor("black")
        self.ax.grid(True, alpha=0.3)
        self.ax.xaxis.pane.fill = False
        self.ax.yaxis.pane.fill = False
        self.ax.zaxis.pane.fill = False

    
    def _update_view_limits(self):
        """Update view limits based on camera and bodies."""
        if self.scene.camera.mode == CameraMode.FOCUS and self.scene.camera.focus_body:
            # Focus mode: tight view around selected body
            center = self.scene.camera.focus_body.pos
            radius = self.scene.camera.distance * 0.5
            
            self.ax.set_xlim(center[0] - radius, center[0] + radius)
            self.ax.set_ylim(center[1] - radius, center[1] + radius)
            self.ax.set_zlim(center[2] - radius, center[2] + radius)
        else:
            # Overview mode: show entire system
            max_dist = 0
            for body in self.scene.system.bodies:
                dist = np.linalg.norm(body.pos)
                max_dist = max(max_dist, dist)
            
            limit = max(max_dist * 1.2, 10.0)
            self.ax.set_xlim(-limit, limit)
            self.ax.set_ylim(-limit, limit)
            self.ax.set_zlim(-limit, limit)
    
    def render(self):
        """Render the current frame."""
        # Clear previous frame
        #self.ax.clear()
        #self._setup_plot()
        
        # Update view limits
        self._update_view_limits()
        
        # Render potential surface
        if self.scene.show_surface:
            self._render_surface()
        
        # Render bodies
        self._render_bodies()
        
        # Render trails
        if self.scene.show_trails:
            self._render_trails()
        
        # Render coordinate axes
        if self.scene.show_axes:
            self._render_axes()
        
        # Render UI elements
        self.scene.ui.render(self)
        
        # Update display
        self.fig.canvas.draw_idle()
    
    def _render_bodies(self):
        """Update body scatter + labels."""
        xs, ys, zs, sizes, colors = [], [], [], [], []
        for body in self.scene.system.bodies:
            xs.append(body.pos[0])
            ys.append(body.pos[1])
            zs.append(body.pos[2])
            sizes.append(float(max(20, get_display_radius(body) * 10000)))
            colors.append(body.color)

            # Update label
            if self.scene.show_labels:
                label = self.body_labels[body.name]
                label.set_position((body.pos[0], body.pos[1]))
                label.set_3d_properties(body.pos[2] + get_display_radius(body))
                label.set_text(body.name)
            else:
                self.body_labels[body.name].set_text("")

        self.body_scatter._offsets3d = (xs, ys, zs)
        self.body_scatter.set_sizes(np.array(sizes, dtype=float))
        self.body_scatter.set_color(colors)

    
    def _render_trails(self):
        """Update orbital trails without recreating lines."""
        for body in self.scene.system.bodies:
            if len(body.trail) > 1:
                trail = np.array(body.trail)[-300:]
                line = self.trail_lines[body.name]
                line.set_data(trail[:, 0], trail[:, 1])
                line.set_3d_properties(trail[:, 2])
    
    def _render_surface(self):
        """Render/update cached gravitational potential surfaces with Gaussian wells."""
        for body in self.scene.system.bodies:
            if body.name.lower() == "sun" or body.mass > 1e-5:
                # Refresh every 10 frames for FPS boost
                if body.name not in self.surface_plots or self.scene.frame_count % 10 == 0:
                    if body.name in self.surface_plots:
                        # Remove old wireframe
                        self.surface_plots[body.name].remove()

                    # Define extent relative to body mass
                    extent = max(2.0, body.mass * 50)
                    grid_size = 40  # slightly higher resolution, still fast
                    x_center, y_center, z_center = body.pos

                    # Use X-Z plane for wells
                    x_range = np.linspace(x_center - extent, x_center + extent, grid_size)
                    z_range = np.linspace(z_center - extent, z_center + extent, grid_size)
                    X, Z = np.meshgrid(x_range, z_range)

                    # Gaussian potential well in Y-axis
                    sigma = extent / 4
                    dx = X - x_center
                    dz = Z - z_center
                    r_squared = dx**2 + dz**2
                    max_depth = -body.mass * 10
                    Y = max_depth * np.exp(-r_squared / (2 * sigma**2))
                    Y = gaussian_filter(Y, sigma=1.0)

                    # Plot wireframe (centered vertically at y_center)
                    self.surface_plots[body.name] = self.ax.plot_wireframe(
                        X, Z, Y + y_center,
                        alpha=0.4, color='cyan', linewidth=0.4,
                        rstride=2, cstride=2
                    )
    
    def _render_axes(self):
        """Render coordinate system axes."""
        # Origin marker
        self.ax.scatter([0], [0], [0], c='white', s=50, marker='+')
        
        # Axis lines (small)
        axis_length = 2.0
        self.ax.plot([0, axis_length], [0, 0], [0, 0], 'r-', alpha=0.5, linewidth=2)  # X
        self.ax.plot([0, 0], [0, axis_length], [0, 0], 'g-', alpha=0.5, linewidth=2)  # Y
        self.ax.plot([0, 0], [0, 0], [0, axis_length], 'b-', alpha=0.5, linewidth=2)  # Z
    

    
    def render_text_panel(self, position, lines):
        """Render a text panel (for UI components)."""
        text = '\n'.join(lines)
        x, y = position
        
        # Convert to normalized coordinates
        x_norm = x / self.fig.get_size_inches()[0] / self.fig.dpi
        y_norm = 1.0 - (y / self.fig.get_size_inches()[1] / self.fig.dpi)
        
        self.ax.text2D(x_norm, y_norm, text, transform=self.ax.transAxes,
                      fontsize=8, color='white', verticalalignment='top',
                      bbox=dict(boxstyle='round', facecolor='black', alpha=0.7))
    
    def show(self):
        """Show the plot window."""
        plt.show()
    
    def save_frame(self, filename):
        """Save current frame to file."""
        self.fig.savefig(filename, facecolor='black', dpi=150)

